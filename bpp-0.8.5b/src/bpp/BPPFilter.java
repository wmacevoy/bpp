/**
    BPP: The Beanshell Preprocessor, version 0.4
    Copyright (C) 2003-2004  Warren D. MacEvoy jr.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package bpp;

import java.util.*;
import java.net.*;
import java.io.*;

/** <p>This is the specific StageFilter for beanshell.</p>

<p>This is a self-deepening filter to recursively preprocess multiple stages of a BPP source file.  Such a filter is configured and used by <a href="BPP.html">BPP</a> to filter files.</p>

<p><b>This is a USE ONCE FILTER</b>.  The pattern of use is:
<ul>
<li>Construct</li>
<li>Configure (set methods)</li>
<li>Filter (use filter method)</li>
<li>discard.</li>
</ul>
In particular, is is quite possible to create a deadlock by attempting to
configure the filter after it begins to filter a stream.</p>

<hr/>
<br/>The Beanshell Preprocessor
<br/>Copyright (C) 2003-2004 Warren D. MacEvoy jr.
*/
public class BPPFilter extends StageFilter {
  public static final int DEFAULT_MAX_LINE_LENGTH=4096;

  private int minStage;
  private int minLineStage;
  private int mode;
  private String source;
  private String destination;
  private String[] args;
  private URL[] classPath;
  private Map stageMap = new TreeMap();

  /** When new stages are forked, this is the source name given to the 
      beanshell interpreter, with [ <i>depth</i> ] appended, so errors
      can be conveniently identified. Undecorated source name is available
      as BPP.source in all stages of the preprocessor. */
  public void setSource(String _source) { source=_source; }

  public String getSource() { return source; }

  /** Convenience method. Destination is available as BPP.destination in
      all stages of the preprocessor. */
  public void setDestination(String _destination) { destination=_destination; }
  public String getDestination() { return destination; }

  /** Convenience method.  Args are available as BPP.args in all stages
      of the processor. */
  public void setArgs(String[] _args) { args=_args; }

  public String[] getArgs() { return args; }

  public void setClassPath(URL[] _classPath)
  {
    classPath=_classPath;
  }

  public URL[] getClassPath() { return classPath; }

  /** 

  <p>Skip later preprocessing stages.</p>

  <p>The normal stages generated by the preprocessor are:
	<table border=1>
	<tr><td><b>stage</b></td><td>1</td><td>2</td><td>3</td><td>4</td><td>...</td></tr>
	<tr><td><b>stage</b></td><td>#interpreter</td><td>#decorator</td><td>##interpreter</td><td>##decorator</td><td>...</td></tr>
nn	</table>
	Setting MinStage to some value other than the default (of zero), forces stages below the MinStage to be replaced by identity filters (that do no transformation to the input).  Thus, for example, to see the output of the ##decorator, use setMinStage(4).  To see the output of running the ##decorated code from running it through the ##interpreter, use setMinStage(3).</p>

  */
  public void setMinStage(int _minStage) {
    minStage=_minStage;
    if (minStage % 2 == 0) {
	    minLineStage = minStage;
    } else {
	    minLineStage = minStage + 1;
    }
    next=minStage/2+1;
  }
  public int getMinStage() { return minStage; }

  public Map getStageMap() { return stageMap; }
  public void setStageMap(Map _stageMap) { stageMap=_stageMap; }

  /** Lines that do not begin with a pound(#), quote, (') or double quote("), are subject to some default translation.  This sets up exact translation by default. */
  public void setModeExact() { mode='\''; }
  /** Lines that do not begin with a pound(#), quote, (') or double quote("), are subject to some default translation.  This sets up magic translation by default. */
  public void setModeMagic() { mode='\"'; }

  private bsh.Interpreter after;

  private Object lock = new Object();
  private int next;

  /** This creates the interpreters in a specific order, so that the 
      before and after relationships can properly be set.  Without this
      serialization, the interpreters can be constructed in an arbitrary
      order.  This results in nondeterministic behavior for the before and
      after values. */
  class Factory extends DefaultBeanshellInterpreterFactory {
    int depth;
    Factory(int _depth) { depth=_depth; }
    public bsh.Interpreter interpreter() { 
	    synchronized(lock) {
        try {
          while (next < depth) {
            try {
              lock.wait();
            } catch (InterruptedException e) { 
              e.printStackTrace(err == null ? System.err : err);
            }
          }
          if (next > depth) 
            throw new RuntimeException("BPPFilter state error.");

          ++next;
		    
          if (BPPFilter.this.source != null) {
            this.setSource(BPPFilter.this.source + "[" + depth + "]");
          }
          bsh.Interpreter ans = Factory.super.interpreter();

          try {
            if (after != null) {
              ans.set("after",after.get("this"));
              after.set("before",ans.get("this"));
            }
            ans.set("BPP",BPPFilter.this);
          } catch (bsh.EvalError e) {
            e.printStackTrace(err);
          }

          after = ans;
          return ans;
        } finally {
          lock.notifyAll();
        }
	    }
    }
  }

  /** Use DEFAULT_MAX_LINE_LENGTH for the maximum line length.  This parameter is needed because of the dynamic staging:  at any point in processing the stream, the filter may decide to back up one line, introduce a new level of preprocessing, and proceed from that point. */
  public BPPFilter() { this(DEFAULT_MAX_LINE_LENGTH); }

  /** This allows for any maximum line length. */
  public BPPFilter(int _maxLineLength) {
    super(0,_maxLineLength); 
    setMinStage(0);
  }


  private int getMagic(String line) {
    int magic =0;
    while (magic < line.length()  && line.charAt(magic) == '#') ++magic;
    if (magic < line.length() && line.charAt(magic) == '\'') return magic+1;
    if (magic < line.length() && line.charAt(magic) == '\"') return magic+1;
    if (mode == '\"' && line.indexOf('$')>=0) return magic+1;
    return magic;
  }

  /** Parse line and determine which stage should be in place to
      interpret it.  Normally internal use only. */
  public int getLineStage(String line) {
    int magic=getMagic(line);
    return Math.max(minLineStage,2*magic);
  }

  /** Produce filter appropriate for a given stage. */
  public Filter getStageFilter() {
    if (stage < minStage) return new DecoratorFilter();
    int depth = (stage+1)/2;
    if (stage%2==1) {
      Factory factory = new Factory(depth);
      factory.setClassPath(classPath);
	    return new BeanshellInterpreterFilter(factory);
    } else {
	    BeanshellDecoratorFilter f=null;
      String filterName = (String)
        ((stageMap != null) ? stageMap.get(new Integer(stage)) : null);
      if (filterName != null) {
        try {
          f = (BeanshellDecoratorFilter) Class.forName(filterName).getConstructor(new Class[]{int.class,int.class}).newInstance(new Object[] { new Integer(depth),new Integer(lineNumber)});
        } catch (Exception e) {
          throw new RuntimeException(e.getMessage(),e);
        }
      } else {
        f = new BeanshellDecoratorFilter(depth,lineNumber);
      }
	    if (mode == '\'') f.defaultCmd=f.exactCmd;
	    else f.defaultCmd=f.magicCmd;
	    return f;
    }
  }
}
