/**
    BPP: The Beanshell Preprocessor, version 0.4
    Copyright (C) 2003-2004  Warren D. MacEvoy jr.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package bpp;

import java.io.*;
import java.net.*;
import java.util.*;

/** 
    <p>This is the main preprocessor class.  See main() for command
    line arguments.</p>

    <hr/>
    <br/>The Beanshell Preprocessor
    <br/>Copyright (C) 2003-2004 Warren D. MacEvoy jr.
*/

public class BPP {

  /** If the bpp.debug property is a non-emtpy string, this
      is initialized to true. */
  public static boolean DEBUG;
  static { 
    try { DEBUG=System.getProperty("bpp.debug").length() > 0; }
    catch (Exception e) { DEBUG=false; }
  }

  String ifile;
  String ofile;
  int mode='\"';
  int minStage=0;
  Map stageMap = new TreeMap();
  int maxLineLength=-1;
  List bpArgs = new ArrayList();
  List bpClassPath = new ArrayList();

  /**
     <p>Command-line interface for the preprocessor.  See <a href="http://bpp.sourceforge.net">http://bpp.sourceforge.net</a> for tutorials and information on using BPP</a>.</p>

     <h2>Examples</h2>
     <ul>
     <p>Example 1.  Process all bpp files in in a directory:
     <code><ul>
     java -jar bp.jar *.bpp
     </ul></code>
     The default output file is the same as the input file, except that the <code>.bpp</code> extension is removed, so a file called <code>Thing.java.bpp</code> will be preprocessed to produce <code>Thing.java</code>.</p>  

     <p>Example 2.  Create beanshell script from a source file:
     <code><ul>
     java -jar bp.jar -b thing.bpp thang.jpp
     </ul></code>
     Files with a <code>.bpp</code> exension will produce <code>.bsh</code> extensions, and <code>.jpp</code> extensions will produce <code>.java</code> extensions.  The internal translations are the same for either extension.
     </p>
     </ul>
     <h2>Command Line Arguments</h2>
     <ul>
     <p>Command line arguments are:
     <table border=1>
     <tr>
     <td valign="top"><b>-q</b></td>
     <td>Quote exact by default. Lines with no particular translation code in column 1 are translated exactly by default.</td>
     </tr>
     <tr>
     <td valign="top"><b>-qq</b></td>
     <td>Quote magically by default. Lines with no particular translation code in column 1 are translated magically by default.  This is the standard behavior of BPP.</td>
     </tr>
     <tr>
     <td valign="top"><b>-b</b></td>
     <td>
     Generate (but do not execute) beanshell script
     <br/>
     <table border=1>
     <tr>
     <td>Source extension</td><td>Default output extension</td>
     </tr>
     <tr><td>.bpp</td><td>.bsh</td></tr>
     <tr><td>.jpp</td><td>.java</td></tr>
     </table>
     This is equivalent to <b>-s 2</b>.
     </td>
     </tr>
     <tr>
     <td valign="top"><b>+b</b></td>
     <td>
     Send beanshell script through bsh and save output generated by script instead.  If the source file ends in .bpp and no output file is specified, then the output file is the same as the input file with the extendsion deleted.  Otherwise the output is sent to the standard output.
     <br/>
     This is equivalent to <b>-s 0</b>.
     </td>
     </tr>
     <tr>
     <td valign="top"><b>-o file</b></td><td>Specify output file ("-" for stdout).</td>
     </tr>
     <tr>
     <td valign="top"><b>-s stage</b></td><td>Generate output from given stage only:
     <table border=1>
     <tr>
     <td><b>Stage</b></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
     </tr>
     <tr>    
     <td><b>Filter</b></td><td>None</td><td>beanshell # interpreter</td><td>beanshell # decorator</td><td>beanshell ## interpreter</td><td>beanshell ## decorator</td><td>...</td></tr>
     </tr>
     </table>
     The decorator filters take input and produces output suitable for running through beanshell.  The interpreter filters are beanshell interpreters executing those scripts.</td>
     </tr>
     <tr>
     <td valign="top"><b>-maxline value</b></td>
     <td>Use this as the maximum line length for the preprocessor instead of the DEFAULT_MAX_LINE_LENGTH.</td>
     </tr>
     <tr>
     <td valign="top"><b>-Dname=value</b></td>
     <td>Set system property (available as <code>System.getProperty(<i>name</i>)</code>).</td>
     </tr>
     <tr>
     <tr>
     <td valign="top"><b>+cp=globbed-paths</b></td>
     <td>Add these to the classpath for each BeanShell interpreter.  Paths are separated by a <b>;</b> and path parts are separated by a <b>/</b>.  See <a href="Unglobber.html">Unglobber</a> for globbing patterns.  I like <code>-cp=--/bpp/bin/++/*.jar;--/bpp/bin/++/classes</code>.  This class path will adjust the class path used <i>by</i> BeanShell, not <i>for</i> BeanShell.  The BPP and BeanShell jar must appear in the standard class path.</td>
     </tr>
     <tr>
     <td valign="top"><b>-a arg</b></td>
     <td>Add <code>arg</code> to the list of args passed to each bsh interpreter. (available as BPP.args)</td>
     </tr>
     <tr>
     <td valign="top"><b>-z</b></td>
     <td>Empty the arg list passed to each bsh interpreter.</td>
     </tr>
     <tr>
     <td valign="top"><b>-u <stage> <class></b></td>
     <td>Use the specified class for the specified stage.  Only even (decorator) stages can be replaced, and the defined stage must be a subclass of the BeanshellDecoratorFilter and have the same constructor.</td>
     </tr>
     </table>
     </ul>
     <h2>Preprocessor automatically defined values:</h2>
     <ul>
     As a file is preprocessed, the follwing variables are set in beanshell:
     <ul>
     <li><b>BPP</b> The top <a href="BPPFilter.html">BPPFilter</a>.</li>
     <li><b>BPP.source</b> The source file name.</li>
     <li><b>BPP.destination</b> The destination file name.</li>
     <li><b>BPP.args</b> The command-line arguments (configured with <b>-a</b> and <b>-z</b>)</li>
     <li><b>after</b> The root namespace for the post-processor of this preprocessor stage (defined only if it exists).  <i>Tricky to use correctly!  Use at your own risk.</i></li>
     <li><b>before</b> The root namespace for the pre-processor of this preprocessor (defined only if it exists).  <i>Tricky to use correctly!  Use at your own risk.</i></li>
     </ul>
     </ul>
  */
  public static void main(String[] args) throws Exception
  {
    new BPP().run(args);
  }

  /** <code>BPP.main(args)</code> is equivalent to <code>new BPP().run(args)</code>. */
  private void run(String [] args) throws Exception {
    for (int i=0; i<args.length; ++i) {
	    if (args[i].equals("-a")) { bpArgs.add(args[++i]); continue; }
	    if (args[i].equals("-z")) { bpArgs.clear(); continue; }
	    if (args[i].equals("-q"))  { mode='\''; continue; }
	    if (args[i].equals("-qq")) { mode='\"'; continue; }
	    if (args[i].equals("-o"))  { ofile=args[++i]; continue; }
	    if (args[i].equals("-b"))  { minStage=2; continue; }
	    if (args[i].equals("+b"))  { minStage=0; continue; }
	    if (args[i].equals("-s"))  { minStage=Integer.parseInt(args[++i]); continue; }
	    if (args[i].equals("-u"))  { 
        Integer stage = Integer.valueOf(args[++i]);
        String filterName = args[++i];
        stageMap.put(stage,filterName);
        continue;
      }
      if (args[i].startsWith("+cp=")) {
        String[] parts = bpp.Format.split(';',args[i].substring(4),true);
        for (int j=0; j<parts.length; ++j) {
          String [] path = bpp.Format.split('/',parts[j],true);
          File [] files = new Unglobber(path).unglob();
          for (int k=0; k<files.length; ++k) {
            try {
              bpClassPath.add(new URL("file","",files[k].getCanonicalPath()));
            } catch (IOException e) {
              throw new RuntimeException(e.getMessage());
            }
          }
        }
        continue;
      }

	    if (args[i].equals("-maxline")) { maxLineLength = Integer.parseInt(args[++i]); continue; }
      if (args[i].length()>2 && args[i].substring(0,2).equals("-D")) {
        int eq=args[i].indexOf('=');
        if (eq >= 0) {
          String name=args[i].substring(2,eq);
          String value=args[i].substring(eq+1);
          System.setProperty(name,value);
          continue;
        }
      }
	    process(args[i]);
    }
  }

  private void process(String _ifile) throws Exception {
    ifile = _ifile;
    if (ofile == null  || ofile.equals("")) {
	    if (ifile.endsWith(".bpp") || ifile.endsWith(".jpp")) {
        if (minStage >= 2 && minStage % 2 == 0) {
          if (ifile.endsWith(".bpp")) {
            ofile = ifile.substring(0,ifile.length()-4) + ".bsh";
          } else { // endsWith(".jpp")
            ofile = ifile.substring(0,ifile.length()-4) + ".java";
          }
        } else {
          ofile = ifile.substring(0,ifile.length()-4);
        }
	    } else ofile="-";
    }

    if (DEBUG) {
	    System.err.println("BPP: ifile=" + ifile);
	    System.err.println("BPP: ofile=" + ofile);
	    System.err.println("BPP: minStage=" + minStage);
	    System.err.println("BPP: args=" + Format.join(',',bpArgs));
      System.err.println("BPP: cp=" + Format.join(';',bpClassPath));
    }

    BPPFilter f = null; 

    if (maxLineLength > 0) {
      f = new BPPFilter(maxLineLength);
    } else {
      f = new BPPFilter();
    }
    f.setSource(ifile);
    f.setDestination(ofile);
    f.setMinStage(minStage);
    f.setStageMap(stageMap);
    
    String [] fargs = new String[bpArgs.size()];
    bpArgs.toArray(fargs);
    f.setArgs(fargs);
    
    URL[] classPath = new URL[bpClassPath.size()];
    bpClassPath.toArray(classPath);
    f.setClassPath(classPath);
    if (mode == '\'') {
      f.setModeExact();
    } else {
      f.setModeMagic();
    }
    BufferedReader in = Filters.getBufferedReader(ifile);
    PrintWriter out = Filters.getPrintWriter(ofile);
    
    f.filter(in,out);
    in.close();
    out.close();
    ofile = null;
  }
}
